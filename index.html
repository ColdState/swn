<html>
<head>
<title>space invaders</title>
</head>
<body>
hello
<hr>
<canvas id="screen" width="200" height="200"></canvas>
<hr>
goodbye
<script>

var keyState = {};

window.onkeydown = function (e) {
    keyState[e.keyCode] = true;
};
window.onkeyup = function (e) {
    keyState[e.keyCode] = false;
};
var canvas = document.getElementById('screen');
canvas.addEventListener('touchstart', function touchStartListener(e) {
  e.preventDefault();
  var touches = e.changedTouches;
  for (var i = 0; i < touches.length; i++) {
    console.log(touches[i].pageX, touches[i].pageY);
    bodies.push(new Invader({
        x: touches[i].pageX,
        y: touches[i].pageY
    }));
  }
}, false);

function isDown(keyCode) {
    return keyState[keyCode] === true;
}
var LEFT = 37;
var RIGHT = 39;
var SPACE = 32;

var screen = canvas.getContext('2d');
var gameSize = {
    x: canvas.width,
    y: canvas.height
};

function Bullet(center, velocity) {
    this.size = {
        x: 3,
        y: 3
    };
    this.center = center;
    this.velocity = velocity;
}

Bullet.prototype.update = function bullet_update() {
    this.center.x += this.velocity.x;
    this.center.y += this.velocity.y;
};


var Player = function () {
    this.size = {
        x: 15,
        y: 15
    };
    this.center = {
        x: gameSize.x / 2,
        y: gameSize.y - this.size.x
    };
};

Player.prototype.update = function player_update() {
    if (isDown(LEFT)) {
        this.center.x -= 2;
    }
    if (isDown(RIGHT)) {
        this.center.x += 2;
    }
    if (isDown(SPACE)) {
        var bullet = new Bullet({
            x: this.center.x,
            y: this.center.y - this.size.y / 2
        }, {
            x: 0,
            y: -6
        });
        addBody(bullet);
    }
};

var Invader = function (center) {
    this.size = {
        x: 15,
        y: 15
    };
    this.center = center;
    this.patrolX = 0;
    this.speedX = 0.3;
};

Invader.prototype.update = function invader_update() {
    if (this.patrolX < 0) {
        this.speedX = Math.abs(this.speedX);
    }
    if (this.patrolX > 40) {
        this.speedX = -1 * Math.abs(this.speedX);
    }
    this.center.x += this.speedX;
    this.patrolX += this.speedX;
    if (Math.random() > 0.95 && !invadersBelow(this)) {
        var bullet = new Bullet({
            x: this.center.x,
            y: this.center.y + this.size.y / 2
        }, {
            x: Math.random() - 0.5,
            y: 6
        });
        addBody(bullet);
    }
};

var bodies = [new Player()];

function addBody(body) {
    bodies.push(body);
}

function drawRect(body) {
    screen.fillRect(
    body.center.x - body.size.x / 2,
    body.center.y - body.size.y / 2,
    body.size.x,
    body.size.y);
}

function colliding(b1, b2) {
    if (b1 === b2) {
        return false;
    }
    if (b1.center.x + b1.size.x / 2 < b2.center.x - b2.size.x / 2) {
        return false;
    }
    if (b1.center.y + b1.size.y / 2 < b2.center.y - b2.size.y / 2) {
        return false;
    }
    if (b1.center.x - b1.size.x / 2 > b2.center.x + b2.size.x / 2) {
        return false;
    }
    if (b1.center.y - b1.size.y / 2 > b2.center.y + b2.size.y / 2) {
        return false;
    }
    return true;
}

function notColliding(i) {
    for (j = i + 1; j < bodies.length; j++) {
        if (colliding(bodies[i], bodies[j])) {
            return false;
        }
    }
    return true;
}

function invadersBelow(invader) {
    var i;
    for (i = 0; i < bodies.length; i++) {
        if (bodies[i] instanceof Invader &&
            bodies[i].center.y > invader.center.y &&
            Math.abs(bodies[i].center.x - invader.center.x) < invader.size.x
            ) {
            return true;
        }
    }
    return false;
}

function tick() {
    var i, j;
    // update
    var newbodies = [];
    for (i = 0; i < bodies.length; i++) {
        if (notColliding(i)) {
            newbodies.push(bodies[i]);
        }
    }
    bodies = newbodies;
    for (i = 0; i < bodies.length; i++) {
        bodies[i].update();
    }
    // draw
    screen.clearRect(0, 0, gameSize.x, gameSize.y);
    for (i = 0; i < bodies.length; i++) {
        drawRect(bodies[i]);
    }
    requestAnimationFrame(tick);
}
console.log('hi');
tick();
</script>
</body>
</html>
