<html>
<head>
<meta name="mobile-web-app-capable" content="yes" />
<title>stars without number</title>
</head>
<body>
<canvas id="it" width="950" height="1425"></canvas>
<script>
(function(){

var bodies = [];
var size = 75;
var cols = 8;
var rows = 10;
var margin = 75;

// functions from redblobgames.com/grids/hexagons
function pixel_to_axial(px, py) {
  px -= margin;
  py -= margin;
  var q = px * (2 / (size * 3));
  var r = (-px / 3 + Math.sqrt(3) / 3 * py) / size;
  return { q: q, r: r, px: px, py: py }
}

function axial_to_cube(input) {
  input.x = input.q;
  input.z = input.r;
  input.y = -input.x-input.z;
  return input;
}

function cube_round(h) {
  var rx = Math.round(h.x);
  var ry = Math.round(h.y);
  var rz = Math.round(h.z);
  var x_diff = Math.abs(rx - h.x);
  var y_diff = Math.abs(ry - h.y);
  var z_diff = Math.abs(rz - h.z);
  if (x_diff > y_diff && x_diff > z_diff) {
    rx = -ry-rz;
  } else if (y_diff > z_diff) {
    yr = -rx-rz;
  } else {
    rz = -rx-ry;
  }
  h.x = rx;
  h.y = ry;
  h.z = rz;
  return h;
}

function cube_to_odd_q(c) {
  c.col = c.x;
  c.row = c.z + (c.x - (c.x & 1)) / 2;
  return c;
}

function odd_q_to_pixel(h) {
  var px = size * (3/2) * h.col + margin;
  var py = size * Math.sqrt(3) * (h.row + 0.5 * (h.col & 1)) + margin;
  return { px: px, py: py };
}

var canvas = document.getElementById('it');
var touching = false
canvas.addEventListener('touchstart', function touchStartListener(e) {
  e.preventDefault();
  touching = true;
}, false);
canvas.addEventListener('touchend', function touchEndListener(e) {
  e.preventDefault();
  var touches = e.changedTouches;
  for (var i = 0; i < touches.length; i++) {
    var x = touches[i].pageX;
    var y = touches[i].pageY;
    var body = cube_to_odd_q(cube_round(axial_to_cube(pixel_to_axial(x, y))));
    if (body.col >= 0 && body.col < cols && body.row >= 0 && body.row < rows) {
      bodies.push(body);
    }
  }
  touching = false;
}, false);
var ctx = canvas.getContext('2d');

function two_digit(x) {
  var tens = Math.floor(x / 10);
  var ones = Math.round(x - tens * 10);
  return tens.toString() + ones.toString();
}

function draw_hexes() { 
  var row, col;
  ctx.strokeStyle = '#ffffff';
  for (row = 0; row < 10; row++ ) {
    for (col = 0; col < 8; col++ ) {
      var p = odd_q_to_pixel({row: row, col:col});
      ctx.beginPath();
      ctx.arc(p.px, p.py, size * 0.8, 0, 2 * Math.PI);
      ctx.stroke();
    }
  }
}

function tick() {
    var i;
    // update
    for (i = 0; i < bodies.length; i++) {
      var target = odd_q_to_pixel(bodies[i]);
      console.log(target.px.toString() + ", " + target.py.toString());
      bodies[i].px = 0.95 * bodies[i].px + 0.05 * target.px;
      bodies[i].py = 0.95 * bodies[i].py + 0.05 * target.py;
    }
    // draw
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#ffffff';
    if (touching) {
      draw_hexes();
    }
    for (i = 0; i < bodies.length; i++) {
        var px = bodies[i].px;
        var py = bodies[i].py;
        var q = bodies[i].q;
        var r = bodies[i].r;
        var x = Math.round(bodies[i].x);
        var y = Math.round(bodies[i].y);
        var z = Math.round(bodies[i].z);
        var col = bodies[i].col;
        var row = bodies[i].row;
        // ctx.fillText(q.toString() + " " + r.toString(), px, py);
        // ctx.fillText(x.toString() + " " + y.toString() + " " + z.toString(), px, py);
        ctx.fillText(two_digit(col) + two_digit(row), px, py);
    }
    requestAnimationFrame(tick);
}
console.log('hi');
tick();

})();
</script>
</body>
</html>
